<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>library_qlabs &mdash; Quanser&#39;s Self Driving Car Virtual Studio Documentation 0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/sphinx_collapse.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tablefix.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/tabs.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
            <a href="../index.html">
            <img src="../_static/quanser_selfdrivingcarstudio.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Getting%20Started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../User%20Interface.html">User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../System/index.html">Python System &amp; Utility Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Objects/index.html">Python Actors Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Code%20Style.html">Code Style</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Quanser's Self Driving Car Virtual Studio Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Module code</a> &raquo;</li>
      <li>library_qlabs</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for library_qlabs</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">quanser.communications</span> <span class="kn">import</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">StreamError</span><span class="p">,</span> <span class="n">PollFlag</span><span class="p">,</span> <span class="n">Timeout</span>

<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">import</span> <span class="nn">time</span>
        
        
<span class="c1">######################### MODULAR CONTAINER CLASS #########################</span>

<div class="viewcode-block" id="CommModularContainer"><a class="viewcode-back" href="../System/qlabs_comm_container.html#library_qlabs.CommModularContainer">[docs]</a><span class="k">class</span> <span class="nc">CommModularContainer</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;The CommModularContainer is a collection of data used to communicate with actors. Multiple containers can be packaged into a single packet.&quot;&quot;&quot;</span>

    <span class="c1"># Define class-level variables   </span>
    <span class="n">containerSize</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;The size of the packet in bytes. Container size (uint32: 4 bytes) + class ID (uint32: 4 bytes) + actor number (uint32: 4 bytes) + actor function (1 byte) + payload (varies per function)&quot;&quot;&quot;</span>
    <span class="n">classID</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;See the class ID variables in the respective library classes.&quot;&quot;&quot;</span>
    <span class="n">actorNumber</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;An identifier that should be unique for each actor of a given class. &quot;&quot;&quot;</span>
    <span class="n">actorFunction</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;See the FCN constants in the respective library classes.&quot;&quot;&quot;</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;A variable sized payload depending on the actor function in use.&quot;&quot;&quot;</span>
       
    <span class="n">ID_GENERIC_ACTOR_SPAWNER</span> <span class="o">=</span> <span class="mi">135</span>
    <span class="sd">&quot;&quot;&quot;The actor spawner is a special actor class that exists in open world environments that manages the spawning and destruction of dynamic actors.&quot;&quot;&quot;</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_SPAWN</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_SPAWN_ACK</span> <span class="o">=</span> <span class="mi">11</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_DESTROY_ACTOR</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_DESTROY_ACTOR_ACK</span> <span class="o">=</span> <span class="mi">13</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_DESTROY_ALL_SPAWNED_ACTORS</span> <span class="o">=</span> <span class="mi">14</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_DESTROY_ALL_SPAWNED_ACTORS_ACK</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_REGENERATE_CACHE_LIST</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_REGENERATE_CACHE_LIST_ACK</span> <span class="o">=</span> <span class="mi">17</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_SPAWN_AND_PARENT_RELATIVE</span> <span class="o">=</span> <span class="mi">50</span>
    <span class="n">FCN_GENERIC_ACTOR_SPAWNER_SPAWN_AND_PARENT_RELATIVE_ACK</span> <span class="o">=</span> <span class="mi">51</span>
    
    
    <span class="n">ID_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="sd">&quot;&quot;&quot;Class ID 0 is reserved as an unknown class. QLabs may respond with a container with information it does not understand due to an unknown class, if data was improperly formatted, or if communication methods were executed in the wrong order.&quot;&quot;&quot;</span>
       
    <span class="n">BASE_CONTAINER_SIZE</span> <span class="o">=</span> <span class="mi">13</span>
    <span class="sd">&quot;&quot;&quot;Container size variable (4 bytes) + class ID (4 bytes) + actor number (4 bytes) + actor function (1 byte). Does not include the payload size which is variable per function.&quot;&quot;&quot;</span>

    <span class="c1"># Initialize class</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

       <span class="k">return</span></div>

<span class="c1">######################### COMMUNICATIONS #########################        </span>
       
<div class="viewcode-block" id="QuanserInteractiveLabs"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs">[docs]</a><span class="k">class</span> <span class="nc">QuanserInteractiveLabs</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This class establishes a server connection with QLabs and manages the communications.&quot;&quot;&quot;</span>
    <span class="n">_stream</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1">#_client_connection = None</span>
    <span class="n">_BUFFER_SIZE</span> <span class="o">=</span> <span class="mi">65537</span>
        
    <span class="n">_readBuffer</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">_BUFFER_SIZE</span><span class="p">)</span>
    <span class="n">_sendBuffer</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>

    <span class="n">_receivePacketBuffer</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
    <span class="n">_receivePacketSize</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_receivePacketContainerIndex</span> <span class="o">=</span> <span class="mi">0</span>  
    <span class="n">_wait_for_container_timeout</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">_send_queue</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>


    <span class="c1"># Initialize QLabs</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Constructor Method &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
<div class="viewcode-block" id="QuanserInteractiveLabs.open"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.open">[docs]</a>    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open a connection to QLabs.</span>

<span class="sd">        :param address: The machine name or IP address of a local or remote copy of QLabs such as &quot;localhost&quot;, or &quot;192.168.1.123&quot;.</span>
<span class="sd">        :param timeout: (Optional) Period to attempt the connection for before aborting. Default 10s.</span>
<span class="sd">        :type address: string</span>
<span class="sd">        :type timeout: float</span>
<span class="sd">        :return: `True` if successful, `False` otherwise</span>
<span class="sd">        :rtype: boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">address</span> <span class="o">=</span> <span class="s2">&quot;tcpip://&quot;</span> <span class="o">+</span> <span class="n">address</span> <span class="o">+</span> <span class="s2">&quot;:18000&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BUFFER_SIZE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BUFFER_SIZE</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">34</span><span class="p">)):</span> <span class="c1"># QERR_WOULD_BLOCK</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connection failure.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">pollResult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="n">Timeout</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">PollFlag</span><span class="o">.</span><span class="n">CONNECT</span><span class="p">)</span>

        <span class="k">while</span> <span class="p">(((</span><span class="n">pollResult</span> <span class="o">&amp;</span> <span class="n">PollFlag</span><span class="o">.</span><span class="n">CONNECT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">PollFlag</span><span class="o">.</span><span class="n">CONNECT</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)):</span>
            <span class="n">pollResult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="n">Timeout</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">PollFlag</span><span class="o">.</span><span class="n">CONNECT</span><span class="p">)</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">pollResult</span> <span class="o">&amp;</span> <span class="n">PollFlag</span><span class="o">.</span><span class="n">CONNECT</span> <span class="o">==</span> <span class="n">PollFlag</span><span class="o">.</span><span class="n">CONNECT</span><span class="p">:</span>
            <span class="c1">#print(&quot;Connection accepted&quot;)</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Connection timeout&quot;</span><span class="p">)</span>
        
            <span class="k">return</span> <span class="kc">False</span>       
        
        <span class="k">return</span> <span class="kc">True</span></div>
        
<div class="viewcode-block" id="QuanserInteractiveLabs.close"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shutdown and close a connection to QLabs. Always close a connection when communications are finished.</span>

<span class="sd">        :return: No return. If an existing connection cannot be found, the function will fail silently.</span>
<span class="sd">        :rtype: none</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>       
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>
            

<div class="viewcode-block" id="QuanserInteractiveLabs.queue_add_container"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.queue_add_container">[docs]</a>    <span class="k">def</span> <span class="nf">queue_add_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Queue a single container into a buffer for future transmission</span>

<span class="sd">        :param container: CommModularContainer populated with the actor information.</span>
<span class="sd">        :type container: CommModularContainer object</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_send_queue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_queue</span> <span class="o">+</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;iiiB&quot;</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">containerSize</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">classID</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">actorNumber</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">actorFunction</span><span class="p">))</span> <span class="o">+</span> <span class="n">container</span><span class="o">.</span><span class="n">payload</span></div>


<div class="viewcode-block" id="QuanserInteractiveLabs.queue_send"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.queue_send">[docs]</a>    <span class="k">def</span> <span class="nf">queue_send</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Package the containers in the queue and transmit immediately</span>

<span class="sd">        :param container: CommModularContainer populated with the actor information.</span>
<span class="sd">        :type container: CommModularContainer object</span>
<span class="sd">        :return: `True` if successful and the queue will be emptied, `False` otherwise and the queue will remain intact.</span>
<span class="sd">        :rtype: boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&lt;iB&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_send_queue</span><span class="p">)))</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_queue</span>
            <span class="n">numBytes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">bytesWritten</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_send_queue</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span> </div>

<div class="viewcode-block" id="QuanserInteractiveLabs.queue_destroy"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.queue_destroy">[docs]</a>    <span class="k">def</span> <span class="nf">queue_destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The container queue is emptied of all data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_send_queue</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span></div>

    <span class="c1"># Pack data and send immediately</span>
<div class="viewcode-block" id="QuanserInteractiveLabs.send_container"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.send_container">[docs]</a>    <span class="k">def</span> <span class="nf">send_container</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Package a single container into a packet and transmit immediately</span>

<span class="sd">        :param container: CommModularContainer populated with the actor information.</span>
<span class="sd">        :type container: CommModularContainer object</span>
<span class="sd">        :return: `True` if successful, `False` otherwise</span>
<span class="sd">        :rtype: boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&lt;i&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="n">container</span><span class="o">.</span><span class="n">containerSize</span><span class="p">))</span> <span class="o">+</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&gt;BiiiB&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">containerSize</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">classID</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">actorNumber</span><span class="p">,</span> <span class="n">container</span><span class="o">.</span><span class="n">actorFunction</span><span class="p">))</span> <span class="o">+</span> <span class="n">container</span><span class="o">.</span><span class="n">payload</span>
            <span class="n">numBytes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">bytesWritten</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numBytes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>      </div>

    <span class="c1"># Check if new data is available.  Returns true if a complete packet has been received.</span>
<div class="viewcode-block" id="QuanserInteractiveLabs.receive_new_data"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.receive_new_data">[docs]</a>    <span class="k">def</span> <span class="nf">receive_new_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  
        <span class="sd">&quot;&quot;&quot;Poll for new data received from QLabs through the communications framework. If you are expecting large amounts of data such as video, this should be executed frequently to avoid overflowing internal buffers. Data split over multiple packets will be automatically reassembled before returning true. This method is non-blocking.</span>

<span class="sd">        :return: `True` if at least one complete container has been received, `False` otherwise</span>
<span class="sd">        :rtype: boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>    
        <span class="n">bytesRead</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bytesRead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readBuffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BUFFER_SIZE</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">StreamError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">error_code</span> <span class="o">==</span> <span class="o">-</span><span class="mi">34</span><span class="p">:</span>
                <span class="c1"># would block</span>
                <span class="n">bytesRead</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">newData</span> <span class="o">=</span> <span class="kc">False</span>
    
        <span class="k">while</span> <span class="n">bytesRead</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span> <span class="o">+=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">:(</span><span class="n">bytesRead</span><span class="p">)])</span>

            <span class="c1">#while we&#39;re here, check if there are any more bytes in the receive buffer</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">bytesRead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readBuffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BUFFER_SIZE</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">StreamError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">error_code</span> <span class="o">==</span> <span class="o">-</span><span class="mi">34</span><span class="p">:</span>
                    <span class="c1"># would block</span>
                    <span class="n">bytesRead</span> <span class="o">=</span> <span class="mi">0</span>
                    
        <span class="c1"># check if we already have data in the receive buffer that was unprocessed (multiple packets in a single receive)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">123</span><span class="p">):</span>
                
                <span class="c1"># packet size</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketSize</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
                <span class="c1"># add the 4 bytes for the size to the packet size</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketSize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketSize</span> <span class="o">+</span> <span class="mi">4</span>          
            
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketSize</span><span class="p">:</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span> <span class="o">=</span> <span class="mi">5</span>
                    <span class="n">newData</span> <span class="o">=</span> <span class="kc">True</span>
                   
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error parsing multiple packets in receive buffer.  Clearing internal buffers.&quot;</span><span class="p">)</span>
                <span class="n">_receivePacketBuffer</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
                
        <span class="k">return</span> <span class="n">newData</span></div>

    <span class="c1"># Parse out received containers</span>
<div class="viewcode-block" id="QuanserInteractiveLabs.get_next_container"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.get_next_container">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_container</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;If receive_new_data has returned true, use this method to receive the next container in the queue.</span>

<span class="sd">        :return: The data will be returned in a CommModularContainer object along with a flag to indicate if additional complete containers remain in the queue for extraction. If this method was used without checking for new data first and the queue is empty, the container will contain the default values with a class ID of ID_UNKNOWN.</span>
<span class="sd">        :rtype: CommModularContainer object, boolean</span>

<span class="sd">        &quot;&quot;&quot;</span>   

        <span class="n">c</span> <span class="o">=</span> <span class="n">CommModularContainer</span><span class="p">()</span>
        <span class="n">isMoreContainers</span> <span class="o">=</span> <span class="kc">False</span>
    
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">c</span><span class="o">.</span><span class="n">containerSize</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;I&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="mi">4</span><span class="p">)])</span>
            <span class="n">c</span><span class="o">.</span><span class="n">classID</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;I&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="mi">4</span><span class="p">):(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="mi">8</span><span class="p">)])</span>
            <span class="n">c</span><span class="o">.</span><span class="n">actorNumber</span><span class="p">,</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;&gt;I&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="mi">8</span><span class="p">):(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="mi">12</span><span class="p">)])</span>
            <span class="n">c</span><span class="o">.</span><span class="n">actorFunction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="mi">12</span><span class="p">]</span>
            <span class="n">c</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="n">c</span><span class="o">.</span><span class="n">BASE_CONTAINER_SIZE</span><span class="p">):(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="o">+</span><span class="n">c</span><span class="o">.</span><span class="n">containerSize</span><span class="p">)])</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">containerSize</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketSize</span><span class="p">):</span>
                
                <span class="n">isMoreContainers</span> <span class="o">=</span> <span class="kc">False</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketSize</span><span class="p">:</span>
                    <span class="c1"># The data buffer contains only the one packet.  Clear the buffer.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Remove the packet from the data buffer.  There is another packet in the buffer already.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span><span class="p">):(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketBuffer</span><span class="p">))]</span>
                    
                <span class="bp">self</span><span class="o">.</span><span class="n">_receivePacketContainerIndex</span> <span class="o">=</span> <span class="mi">0</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isMoreContainers</span> <span class="o">=</span> <span class="kc">True</span>
                
    
        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">isMoreContainers</span>   </div>

<div class="viewcode-block" id="QuanserInteractiveLabs.set_wait_for_container_timeout"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.set_wait_for_container_timeout">[docs]</a>    <span class="k">def</span> <span class="nf">set_wait_for_container_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;By default, a method using the wait_for_container method (typically represented with the waitForComfirmation flag) will abort waiting for an acknowledgment after 5 seconds</span>
<span class="sd">        at which time the method will return a failed response. This time period can be adjusted with this function. Values </span>
<span class="sd">        less than or equal to zero will cause the methods to wait indefinitely until the expected acknowledgment is received.</span>

<span class="sd">        :param timeout: Timeout period in seconds</span>
<span class="sd">        :type timeout: float</span>

<span class="sd">        &quot;&quot;&quot;</span>   


        <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_container_timeout</span> <span class="o">=</span> <span class="n">timeout</span></div>



<div class="viewcode-block" id="QuanserInteractiveLabs.wait_for_container"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.wait_for_container">[docs]</a>    <span class="k">def</span> <span class="nf">wait_for_container</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">classID</span><span class="p">,</span> <span class="n">actorNumber</span><span class="p">,</span> <span class="n">functionNumber</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Continually poll and parse incoming containers until a response from specific actor with a specific function response is received. </span>
<span class="sd">        Containers that do not match the class, actor number, and function number are discarded. This function blocks until the appropriate packet</span>
<span class="sd">        is received or the timeout is reached.</span>

<span class="sd">        :return: The data will be returned in a CommModularContainer object.</span>
<span class="sd">        :rtype: CommModularContainer object</span>

<span class="sd">        &quot;&quot;&quot;</span>   

        <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">while</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">receive_new_data</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_container_timeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">currentTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">currentTime</span> <span class="o">-</span> <span class="n">startTime</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wait_for_container_timeout</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">None</span>
                <span class="k">pass</span>
                
            <span class="n">moreContainers</span> <span class="o">=</span> <span class="kc">True</span>
            
            <span class="k">while</span> <span class="p">(</span><span class="n">moreContainers</span><span class="p">):</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">moreContainers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_container</span><span class="p">()</span>
                
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">classID</span> <span class="o">==</span> <span class="n">classID</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">actorNumber</span> <span class="o">==</span> <span class="n">actorNumber</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">actorFunction</span> <span class="o">==</span> <span class="n">functionNumber</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">c</span></div>
                            
<div class="viewcode-block" id="QuanserInteractiveLabs.flush_receive"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.flush_receive">[docs]</a>    <span class="k">def</span> <span class="nf">flush_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush receive buffers removing all unread data. This can be used to clear receive buffers after fault conditions to ensure it contains only new data.</span>

<span class="sd">        :return: None</span>
<span class="sd">        :rtype: None</span>

<span class="sd">        &quot;&quot;&quot;</span>   
        <span class="k">try</span><span class="p">:</span>
            <span class="n">bytesRead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stream</span><span class="o">.</span><span class="n">receive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_readBuffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_BUFFER_SIZE</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">StreamError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">error_code</span> <span class="o">==</span> <span class="o">-</span><span class="mi">34</span><span class="p">:</span>
                <span class="c1"># would block</span>
                <span class="n">bytesRead</span> <span class="o">=</span> <span class="mi">0</span></div>
               
    <span class="k">def</span> <span class="nf">regenerate_cache_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Advanced function for actor indexing.</span>
<span class="sd">        </span>
<span class="sd">        :return: `True` if successful, `False` otherwise</span>
<span class="sd">        :rtype: boolean</span>

<span class="sd">        .. danger::</span>

<span class="sd">            TODO: Improve this description.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">CommModularContainer</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">classID</span> <span class="o">=</span> <span class="n">CommModularContainer</span><span class="o">.</span><span class="n">ID_GENERIC_ACTOR_SPAWNER</span>
        <span class="n">c</span><span class="o">.</span><span class="n">actorNumber</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span><span class="o">.</span><span class="n">actorFunction</span> <span class="o">=</span> <span class="n">CommModularContainer</span><span class="o">.</span><span class="n">FCN_GENERIC_ACTOR_SPAWNER_REGENERATE_CACHE_LIST</span>
        <span class="n">c</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">containerSize</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">BASE_CONTAINER_SIZE</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">send_container</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wait_for_container</span><span class="p">(</span><span class="n">CommModularContainer</span><span class="o">.</span><span class="n">ID_GENERIC_ACTOR_SPAWNER</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">actorNumber</span><span class="p">,</span> <span class="n">CommModularContainer</span><span class="o">.</span><span class="n">FCN_GENERIC_ACTOR_SPAWNER_REGENERATE_CACHE_LIST_ACK</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="QuanserInteractiveLabs.ping"><a class="viewcode-back" href="../System/qlabs_core.html#library_qlabs.QuanserInteractiveLabs.ping">[docs]</a>    <span class="k">def</span> <span class="nf">ping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qlabs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;QLabs will automatically disconnect a non-responsive client connection. The ping method can be used to keep the connection alive if operations are infrequent.</span>
<span class="sd">        </span>
<span class="sd">        :param qlabs: A QuanserInteractiveLabs object.</span>
<span class="sd">        :type qlabs: QuanserInteractiveLabs object</span>
<span class="sd">        :return: `True` if successful, `False` otherwise</span>
<span class="sd">        :rtype: boolean</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">FCN_REQUEST_PING</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">FCN_RESPONSE_PING</span> <span class="o">=</span> <span class="mi">2</span>
    

        <span class="n">c</span> <span class="o">=</span> <span class="n">CommModularContainer</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">classID</span> <span class="o">=</span> <span class="n">CommModularContainer</span><span class="o">.</span><span class="n">ID_GENERIC_ACTOR_SPAWNER</span>
        <span class="n">c</span><span class="o">.</span><span class="n">actorNumber</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span><span class="o">.</span><span class="n">actorFunction</span> <span class="o">=</span> <span class="n">FCN_REQUEST_PING</span>
        <span class="n">c</span><span class="o">.</span><span class="n">payload</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">containerSize</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">BASE_CONTAINER_SIZE</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">payload</span><span class="p">)</span>
        
        <span class="n">qlabs</span><span class="o">.</span><span class="n">flush_receive</span><span class="p">()</span>        
                
        <span class="k">if</span> <span class="p">(</span><span class="n">qlabs</span><span class="o">.</span><span class="n">send_container</span><span class="p">(</span><span class="n">c</span><span class="p">)):</span>
        
            <span class="n">c</span> <span class="o">=</span> <span class="n">qlabs</span><span class="o">.</span><span class="n">wait_for_container</span><span class="p">(</span><span class="n">CommModularContainer</span><span class="o">.</span><span class="n">ID_GENERIC_ACTOR_SPAWNER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FCN_RESPONSE_PING</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="n">c</span><span class="o">.</span><span class="n">payload</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span> </div>

   
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Destructor Method &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Quanser.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>